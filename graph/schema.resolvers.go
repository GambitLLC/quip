package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.30

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/google/uuid"
	pkgerr "github.com/pkg/errors"
	"golang.org/x/oauth2"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/oauth"
	"google.golang.org/protobuf/types/known/emptypb"

	"github.com/GambitLLC/quip/graph/model"
	"github.com/GambitLLC/quip/libs/auth"
	"github.com/GambitLLC/quip/libs/pb/matchmaker"
)

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, changes map[string]interface{}) (bool, error) {
	log.Printf("%+v", changes)
	return true, nil
}

// StartQueue is the resolver for the startQueue field.
func (r *mutationResolver) StartQueue(ctx context.Context, gamemode string) (bool, error) {
	token := auth.TokenFromContext(ctx)
	_, err := r.frontend.StartQueue(ctx, &matchmaker.StartQueueRequest{
		Config: &matchmaker.GameConfiguration{
			Gamemode: gamemode,
		},
	}, grpc.PerRPCCredentials(oauth.TokenSource{
		TokenSource: oauth2.StaticTokenSource(&oauth2.Token{
			AccessToken: token,
		}),
	}))

	if err != nil {
		return false, err
	}

	return true, nil
}

// StopQueue is the resolver for the stopQueue field.
func (r *mutationResolver) StopQueue(ctx context.Context) (bool, error) {
	token := auth.TokenFromContext(ctx)
	_, err := r.frontend.StopQueue(ctx, &emptypb.Empty{}, grpc.PerRPCCredentials(oauth.TokenSource{
		TokenSource: oauth2.StaticTokenSource(&oauth2.Token{
			AccessToken: token,
		}),
	}))

	if err != nil {
		return false, err
	}

	return true, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id *string) (*model.User, error) {
	if id == nil {
		userId := auth.UserFromContext(ctx)
		id = &userId
	}

	return &model.User{
		ID: *id,
	}, nil
}

// State is the resolver for the state field.
func (r *statusResolver) State(ctx context.Context, obj *model.Status) (model.State, error) {
	return model.State(obj.State), nil
}

// Details is the resolver for the details field.
func (r *statusResolver) Details(ctx context.Context, obj *model.Status) (model.StatusDetails, error) {
	// NOTE: gqlgen generate erroneously removes pkg/errors and replaces with stdlib errors
	// name import github.com/pkg/errors as a workaround
	// https://github.com/99designs/gqlgen/issues/1171
	switch details := obj.Details.(type) {
	default:
		return nil, pkgerr.Errorf("invalid status detail type: %T", details)
	case *matchmaker.Status_Matched:
		return &model.MatchFound{MatchFound: details.Matched}, nil
	case *matchmaker.Status_Searching:
		return &model.QueueSearching{QueueSearching: details.Searching}, nil
	case *matchmaker.Status_Stopped:
		return &model.QueueStopped{QueueStopped: details.Stopped}, nil

	}
}

// Status is the resolver for the status field.
func (r *statusUpdateResolver) Status(ctx context.Context, obj *model.StatusUpdate) (*model.Status, error) {
	return &model.Status{Status: obj.Status}, nil
}

// Status is the resolver for the status field.
func (r *subscriptionResolver) Status(ctx context.Context, targets []string) (<-chan *model.StatusUpdate, error) {
	userId := auth.UserFromContext(ctx)
	if userId == "" {
		return nil, pkgerr.New("unauthenticated")
	}

	id := uuid.New().String()
	go func() {
		<-ctx.Done()
		r.Unsubscribe(id)
	}()

	return r.Subscribe(id, append(targets, userId))
}

// Status is the resolver for the status field.
func (r *userResolver) Status(ctx context.Context, obj *model.User) (*model.Status, error) {
	token := auth.TokenFromContext(ctx)
	status, err := r.frontend.GetStatus(ctx, &matchmaker.GetStatusRequest{
		Target: obj.ID,
	}, grpc.PerRPCCredentials(oauth.TokenSource{
		TokenSource: oauth2.StaticTokenSource(&oauth2.Token{
			AccessToken: token,
		}),
	}))

	if err != nil {
		// TODO: wrap/fmt err instead of directly returning
		return nil, err
	}

	return &model.Status{
		Status: status,
	}, nil
}

// Profile is the resolver for the profile field.
func (r *userResolver) Profile(ctx context.Context, obj *model.User) (*model.Profile, error) {
	date := time.Now()
	return &model.Profile{
		Username: fmt.Sprintf("user: %s", obj.ID),
		Dob:      &date,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Status returns StatusResolver implementation.
func (r *Resolver) Status() StatusResolver { return &statusResolver{r} }

// StatusUpdate returns StatusUpdateResolver implementation.
func (r *Resolver) StatusUpdate() StatusUpdateResolver { return &statusUpdateResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type statusResolver struct{ *Resolver }
type statusUpdateResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
